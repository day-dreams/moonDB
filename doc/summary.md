<!-- TOC -->

- [1. 遇到的问题](#1-遇到的问题)
    - [1.1. 数据库引擎](#11-数据库引擎)
        - [1.1.1. B+树在数据库中起到什么作用](#111-b树在数据库中起到什么作用)
        - [1.1.2. 操作系统如何打开并读取一个文件](#112-操作系统如何打开并读取一个文件)
    - [1.2. 网络](#12-网络)
        - [1.2.1. 如何对流式数据进行解析](#121-如何对流式数据进行解析)
- [2. 细节](#2-细节)
    - [2.1. C++层面](#21-c层面)
        - [2.1.1. 饿汉单例与懒汉单例](#211-饿汉单例与懒汉单例)
        - [2.1.2. union仅限于传统c的方式去使用](#212-union仅限于传统c的方式去使用)
    - [2.2. 第三方库](#22-第三方库)
        - [2.2.1. easyloggingpp现在不在是header only了](#221-easyloggingpp现在不在是header-only了)

<!-- /TOC -->

# 1. 遇到的问题
## 1.1. 数据库引擎
这里记录造轮子过程中的一些问题。

### 1.1.1. B+树在数据库中起到什么作用
>问题描述：   B+树在数据库中处于什么地位？具体完成什么任务？  
>参考链接：

### 1.1.2. 操作系统如何打开并读取一个文件
>问题描述：  在linux下，文件是如何被打开并读取的呢？  
>参考链接：  
    [从内核文件系统看文件读写过程](http://www.cnblogs.com/huxiao-tee/p/4657851.html)  
    [open()在Linux内核的实现](http://edsionte.com/techblog/archives/4470)  
    [read 系统调用剖析](https://www.ibm.com/developerworks/cn/linux/l-cn-read/)

* 打开  
按我的理解，”打开一个文件“这个动作由open()函数完成。可以认为，open接受的输入参数包括文件路径和读写权限。经过路径查找和权限检查后，如果成功，open会在内核中创建一个数据结构(后续会利用这个数据结构去进行读写操作)，并返回一个文件描述符(file descriptor)，用户的程序通过这个描述符去访问文件内容。  
open()的功能是**Given  a pathname for a file, open() returns a file descriptor**。主要包含的动作包括：文件路径查找，内核相关数据结构生成，文件描述符生成，文件打开(由VFS完成，涉及读cache和写buffer)。据说，路径查找是主要的步骤。
* 读取  
读取由read()完成。到这里没有什么兴趣深究下去了，猜测应该包含cache的复制、重新写入等，还是通过文件描述符去访问相应的结构。

## 1.2. 网络

### 1.2.1. 如何对流式数据进行解析
>问题描述：  TCP是流式协议，一次recv可能会收到多个请求，如何解析呢？
>参考链接：  


# 2. 细节

这里记录一些细节上的东西。


## 2.1. C++层面

### 2.1.1. 饿汉单例与懒汉单例

要注意线程安全。

### 2.1.2. union仅限于传统c的方式去使用
原因如下:
* 带有类成员的union的各种构造函数都是delete的  
* 作为union组成部分的类成员无法自动析构   
    这意味这你需要自己管理构造函数，析构函数等。根据实际类型去析构。
* 每次切换union的数据成员，都需要重新分配内存  
    特别是有动态大小的成员类时，随意切换会直接导致SegmentFault。  

**要么用传统c的方式去使用union，要么不用!**

## 2.2. 第三方库

### 2.2.1. easyloggingpp现在不在是header only了

用起来还是有点麻烦。